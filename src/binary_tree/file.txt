/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bt_parser.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembo    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 13:04:50 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 22:40:33 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_node	*parse_semicolon(t_parser *parser)
{
	t_node	*left;
	t_node	*right;

	left = parse_logical(parser);
	if (peek(parser) == SEMICOLON)
	{
		consume(parser);
		right = parse_semicolon(parser);
		return (create_node(SEMICOLON, left, right));
	}
	return (left);
}

t_node	*parse_logical(t_parser *parser)
{
	t_node	*left;
	t_node	*right;
	t_type	op;

	left = parse_pipeline(parser);
	while (peek(parser) == LOGICAL_AND || peek(parser) == LOGICAL_OR)
	{
		op = peek(parser);
		consume(parser);
		right = parse_logical(parser);
		left = create_node(op, left, right);
	}
	return (left);
}

t_node	*parse_pipeline(t_parser *parser)
{
	t_node	*left;
	t_node	*right;

	left = parse_grouping(parser);
	if (peek(parser) == PIPE)
	{
		consume(parser);
		right = parse_pipeline(parser);
		return (create_node(PIPE, left, right));
	}
	return (left);
}

/*
 * 1. Collecting commands by allocating based on MAX_ARGS size
 * 2. Collecitng tokens until an operator is found
 * 3. Creating a leaf based on that node
 * 4. Attach redirections if any
 */
t_node	*parse_command(t_parser *parser)
{
	char	**args;
	int		arg_count;
	t_node	*cmd_node;

	args = malloc(MAX_ARGS * sizeof(char *));
	arg_count = 0;
	while (parser->pos < MAX_TOKENS
		&& parser->tokens[parser->pos].type == WORD)
	{
		args[arg_count++] = ft_strdup(parser->tokens[parser->pos].value);
		parser->pos++;
	}
	args[arg_count] = NULL;
	cmd_node = create_leaf(args);
	parse_redirects(parser, cmd_node);
	return (cmd_node);
}

/* 1. Check si le token suivant est une redirection
 * 2. Assignation du type de redir
 * 3. Le filename devient la valeur du token parsee 
 * 4. Ajout de la comande de redirection
 * !! Creer une fct handle_error qui "free??" au peek + if (!new_redirs)
 */
void	parse_redirects(t_parser *parser, t_node *cmd_node)
{
	t_redir	redir;
	t_redir	*new_redirs;

	while (is_redirection(peek(parser)))
	{
		redir.type = parser->tokens[parser->pos].type;
		parser->pos++;
		if (parser->pos >= MAX_TOKENS || peek(parser) != WORD)
		{
			free_tree(cmd_node);
			ft_printf("Missing filename for redirection");
			parser->pos = MAX_TOKENS;
			return ;
		}
		redir.filename = ft_strdup(parser->tokens[parser->pos].value);
		parser->pos++;
		new_redirs = ft_realloc(cmd_node->redirs,
				cmd_node->redir_count * sizeof(t_redir),
				(cmd_node->redir_count + 1) * sizeof(t_redir));
		if (!new_redirs)
		{
			free_tree(cmd_node);
			exit(1);
		}
		cmd_node->redirs = new_redirs;
		cmd_node->redirs[cmd_node->redir_count++] = redir;
	}
}

t_node	*parse_grouping(t_parser *parser)
{
	t_node	*subtree;

	if (peek(parser) == GROUPING_OPEN)
	{
		consume(parser);
		subtree = parse_semicolon(parser);
		if (peek(parser) != GROUPING_CLOSE)
		{
			ft_printf("Syntax error: unclosed grouping");
			parser->pos = MAX_TOKENS;
			return (NULL);
		}
		consume(parser);
		return (subtree);
	}
	else
		return (parse_command(parser));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bt_parser_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 19:41:16 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 19:43:06 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_type	peek(t_parser *parser)
{
	return (parser->tokens[parser->pos].type);
}

void	consume(t_parser *parser)
{
	parser->pos++;
}

int	is_redirection(t_type type)
{
	return (type == REDIRECT_IN || type == REDIRECT_OUT
		|| type == APPEND || type == HEREDOC);
}

t_node	*parse(t_parser *parser)
{
	return (parse_semicolon(parser));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_mgmt.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 21:05:43 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/31 21:08:48 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	execute(t_node *node)
{
	if (!node)
		return ;
	if (node->type == CMD)
		execute_cmd(node);
	if (node->type == PIPE)
		execute_pipe(node);
	if (node->type == SEMICOLON)
		execute_semicolon(node);
	if (node->type == LOGICAL_AND || node->type == LOGICAL_OR)
		execute_logical(node);
}

int	handle_heredoc(char *delimiter)
{
	char	*line;
	int		pipefd[2];

	pipe(pipefd);
	while (1)
	{
		line = readline(">");
		if (!line || ft_strcmp(line, delimiter) == 0)
			break ;
		write(pipefd[1], line, ft_strlen(line));
		write(pipefd[1], "\n", 1);
		free(line);
	}
	free(line);
	close(pipefd[1]);
	return (pipefd[0]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_ops.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 21:09:25 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/31 23:22:07 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	execute_cmd(t_node *cmd)
{
	pid_t	pid;
	int		status;

	if (handle_redirections(cmd) != 0)
		return ;
	pid = fork();
	if (pid == 0)
	{
		if (execvp(cmd->args[0], cmd->args) == -1)
		{
			perror("minishell");
			exit(EXIT_FAILURE);
		}
	}
	else if (pid < 0)
		perror("minishell");
	else
		waitpid(pid, &status, 0);
}

void	execute_pipe(t_node *pipe_node)
{
	int		fd[2];
	pid_t	pid_left;
	pid_t	pid_right;

	if (pipe(fd) == -1)
	{
		perror("minishell");
		return ;
	}
	pid_left = fork();
	if (pid_left == 0)
	{
		close(fd[0]);
		dup2(fd[1], STDOUT_FILENO);
		execute(pipe_node->writer);
		close(fd[1]);
		exit(EXIT_SUCCESS);
	}
	pid_right = fork();
	if (pid_right == 0)
	{
		close(fd[1]);
		dup2(fd[0], STDIN_FILENO);
		execute(pipe_node->reader);
		close(fd[0]);
		exit(EXIT_SUCCESS);
	}
	close(fd[0]);
	close(fd[1]);
	waitpid(pid_left, NULL, 0);
	waitpid(pid_right, NULL, 0);
}

/* DOCS : WIFEXITED && WEXITSTATUS-> A voir si macros interdites...
 * 		Si c'est le cas, le code sera a repenser voir les recreer
 * https://sites.uclouvain.be/SystInfo/usr/include/bits/waitstatus.h.html
 */
void	execute_logical(t_node *logical_node)
{
	int	status;

	execute(logical_node->writer);
	wait(&status);
	if (logical_node->type == LOGICAL_AND && WIFEXITED(status)
		&& WEXITSTATUS(status) == 0)
		execute(logical_node->reader);
	else if (logical_node->type == LOGICAL_OR && WIFEXITED(status)
		&& WEXITSTATUS(status) != 0)
		execute(logical_node->reader);
}

void	execute_semicolon(t_node *semi_node)
{
	execute(semi_node->writer);
	execute(semi_node->reader);
}

int	handle_redirections(t_node *cmd)
{
	int	fd;
	int	i;

	i = -1;
	while (++i < cmd->redir_count)
	{
		if (cmd->redirs[i].type == REDIRECT_OUT)
			fd = open(cmd->redirs[i].filename,
					O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (cmd->redirs[i].type == APPEND)
			fd = open(cmd->redirs[i].filename,
					O_WRONLY | O_CREAT | O_APPEND, 0644);
		else if (cmd->redirs[i].type == REDIRECT_IN)
			fd = open(cmd->redirs[i].filename, O_RDONLY);
		else if (cmd->redirs[i].type == HEREDOC)
			fd = handle_heredoc(cmd->redirs[i].filename);
		if (fd == -1)
		{
			perror("minishell");
			return (-1);
		}
		if (cmd->redirs[i].type == REDIRECT_IN
			|| cmd->redirs[i].type == HEREDOC)
			dup2(fd, STDIN_FILENO);
		else
			dup2(fd, STDOUT_FILENO);
		close(fd);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_tree.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 18:39:48 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 18:47:30 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	free_tree(t_node *node)
{
	int	i;

	i = 0;
	if (!node)
		return ;
	free_tree(node->writer);
	free_tree(node->reader);
	if (node->type == CMD)
	{
		i = 0;
		while (node->args[i])
		{
			free(node->args[i]);
			i++;
		}
		free(node->args);
	}
	i = 0;
	while (i < node->redir_count)
	{
		free(node->redirs[i].filename);
		i++;
	}
	free(node->redirs);
	free(node);
}

void	free_tokens(t_token	*tokens)
{
	int	i;

	i = 0;
	while (tokens[i].type != END)
	{
		free(tokens[i].value);
		i++;
	}
	free(tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   binary_tree.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 11:40:00 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 11:55:26 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_node	*create_leaf(char **args)
{
	t_node	*node;

	node = malloc(sizeof(t_node));
	node->type = CMD;
	node->args = args;
	node->writer = NULL;
	node->reader = NULL;
	node->redirs = NULL;
	node->redir_count = 0;
	return (node);
}

t_node	*create_node(t_type type, t_node *left, t_node *right)
{
	t_node	*node;

	node = malloc(sizeof(t_node));
	node->type = type;
	node->args = NULL;
	node->writer = left;
	node->reader = right;
	node->redirs = NULL;
	node->redir_count = 0;
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembo    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 21:27:25 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 22:53:59 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	print_tree(t_node *node, int depth)
{
	int	i;

	if (!node)
		return ;
	ft_printf("\n");
	//print_tree(node->reader, depth + 4);
	i = 0;
	while (i < depth)
	{
		ft_printf(" ");
		i++;
	}
	if (node->type == CMD)
	{
		ft_printf("CMD: ");
		i = 0;
		while (node->args[i])
		{
			ft_printf("%s ", node->args[i]);
			i++;
		}
		i = 0;
		while (i < node->redir_count)
		{
			ft_printf("[%s %s]", redir_type_str(node->redirs[i].type),
				node->redirs[i].filename);
			i++;
		}
		ft_printf("\n");
	}
	else
	{
		ft_printf("OP: %s\n", type_to_str(node->type));
		print_tree(node->writer, depth + 1);
		print_tree(node->reader, depth + 1);
	}
	//print_tree(node->writer, depth + 4);
}
/*
 * ast = https://deepsource.com/glossary/ast 
 */
int	main(void)
{
	char		*rl;
	t_token		*tokens;
	t_parser	parser;
	t_node		*ast;

	while ((rl = readline("minishell> ")) != NULL)
	{
		if (ft_strlen(rl) > 0)
			add_history(rl);
		ft_printf("\n");
		tokens = tokenize(rl);
		parser = (t_parser){tokens, 0};
		ast = parse(&parser);
		print_tree(ast, 0);
		//execute(ast);
		free_tree(ast);
		free_tokens(tokens);
		free(rl);
	}
	//free_tree(ast);
	//free_tokens(tokens);
	//free(rl);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bt_parser.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembo    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 13:04:50 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 22:40:33 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_node	*parse_semicolon(t_parser *parser)
{
	t_node	*left;
	t_node	*right;

	left = parse_logical(parser);
	if (peek(parser) == SEMICOLON)
	{
		consume(parser);
		right = parse_semicolon(parser);
		return (create_node(SEMICOLON, left, right));
	}
	return (left);
}

t_node	*parse_logical(t_parser *parser)
{
	t_node	*left;
	t_node	*right;
	t_type	op;

	left = parse_pipeline(parser);
	while (peek(parser) == LOGICAL_AND || peek(parser) == LOGICAL_OR)
	{
		op = peek(parser);
		consume(parser);
		right = parse_logical(parser);
		left = create_node(op, left, right);
	}
	return (left);
}

t_node	*parse_pipeline(t_parser *parser)
{
	t_node	*left;
	t_node	*right;

	left = parse_grouping(parser);
	if (peek(parser) == PIPE)
	{
		consume(parser);
		right = parse_pipeline(parser);
		return (create_node(PIPE, left, right));
	}
	return (left);
}

/*
 * 1. Collecting commands by allocating based on MAX_ARGS size
 * 2. Collecitng tokens until an operator is found
 * 3. Creating a leaf based on that node
 * 4. Attach redirections if any
 */
t_node	*parse_command(t_parser *parser)
{
	char	**args;
	int		arg_count;
	t_node	*cmd_node;

	args = malloc(MAX_ARGS * sizeof(char *));
	arg_count = 0;
	while (parser->pos < MAX_TOKENS
		&& parser->tokens[parser->pos].type == WORD)
	{
		args[arg_count++] = ft_strdup(parser->tokens[parser->pos].value);
		parser->pos++;
	}
	args[arg_count] = NULL;
	cmd_node = create_leaf(args);
	parse_redirects(parser, cmd_node);
	return (cmd_node);
}

/* 1. Check si le token suivant est une redirection
 * 2. Assignation du type de redir
 * 3. Le filename devient la valeur du token parsee 
 * 4. Ajout de la comande de redirection
 * !! Creer une fct handle_error qui "free??" au peek + if (!new_redirs)
 */
void	parse_redirects(t_parser *parser, t_node *cmd_node)
{
	t_redir	redir;
	t_redir	*new_redirs;

	while (is_redirection(peek(parser)))
	{
		redir.type = parser->tokens[parser->pos].type;
		parser->pos++;
		if (parser->pos >= MAX_TOKENS || peek(parser) != WORD)
		{
			free_tree(cmd_node);
			ft_printf("Missing filename for redirection");
			parser->pos = MAX_TOKENS;
			return ;
		}
		redir.filename = ft_strdup(parser->tokens[parser->pos].value);
		parser->pos++;
		new_redirs = ft_realloc(cmd_node->redirs,
				cmd_node->redir_count * sizeof(t_redir),
				(cmd_node->redir_count + 1) * sizeof(t_redir));
		if (!new_redirs)
		{
			free_tree(cmd_node);
			exit(1);
		}
		cmd_node->redirs = new_redirs;
		cmd_node->redirs[cmd_node->redir_count++] = redir;
	}
}

t_node	*parse_grouping(t_parser *parser)
{
	t_node	*subtree;

	if (peek(parser) == GROUPING_OPEN)
	{
		consume(parser);
		subtree = parse_semicolon(parser);
		if (peek(parser) != GROUPING_CLOSE)
		{
			ft_printf("Syntax error: unclosed grouping");
			parser->pos = MAX_TOKENS;
			return (NULL);
		}
		consume(parser);
		return (subtree);
	}
	else
		return (parse_command(parser));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   bt_parser_utils.c                                  :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 19:41:16 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 19:43:06 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_type	peek(t_parser *parser)
{
	return (parser->tokens[parser->pos].type);
}

void	consume(t_parser *parser)
{
	parser->pos++;
}

int	is_redirection(t_type type)
{
	return (type == REDIRECT_IN || type == REDIRECT_OUT
		|| type == APPEND || type == HEREDOC);
}

t_node	*parse(t_parser *parser)
{
	return (parse_semicolon(parser));
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_mgmt.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 21:05:43 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/31 21:08:48 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	execute(t_node *node)
{
	if (!node)
		return ;
	if (node->type == CMD)
		execute_cmd(node);
	if (node->type == PIPE)
		execute_pipe(node);
	if (node->type == SEMICOLON)
		execute_semicolon(node);
	if (node->type == LOGICAL_AND || node->type == LOGICAL_OR)
		execute_logical(node);
}

int	handle_heredoc(char *delimiter)
{
	char	*line;
	int		pipefd[2];

	pipe(pipefd);
	while (1)
	{
		line = readline(">");
		if (!line || ft_strcmp(line, delimiter) == 0)
			break ;
		write(pipefd[1], line, ft_strlen(line));
		write(pipefd[1], "\n", 1);
		free(line);
	}
	free(line);
	close(pipefd[1]);
	return (pipefd[0]);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   exec_ops.c                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/31 21:09:25 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/31 23:22:07 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	execute_cmd(t_node *cmd)
{
	pid_t	pid;
	int		status;

	if (handle_redirections(cmd) != 0)
		return ;
	pid = fork();
	if (pid == 0)
	{
		if (execvp(cmd->args[0], cmd->args) == -1)
		{
			perror("minishell");
			exit(EXIT_FAILURE);
		}
	}
	else if (pid < 0)
		perror("minishell");
	else
		waitpid(pid, &status, 0);
}

void	execute_pipe(t_node *pipe_node)
{
	int		fd[2];
	pid_t	pid_left;
	pid_t	pid_right;

	if (pipe(fd) == -1)
	{
		perror("minishell");
		return ;
	}
	pid_left = fork();
	if (pid_left == 0)
	{
		close(fd[0]);
		dup2(fd[1], STDOUT_FILENO);
		execute(pipe_node->writer);
		close(fd[1]);
		exit(EXIT_SUCCESS);
	}
	pid_right = fork();
	if (pid_right == 0)
	{
		close(fd[1]);
		dup2(fd[0], STDIN_FILENO);
		execute(pipe_node->reader);
		close(fd[0]);
		exit(EXIT_SUCCESS);
	}
	close(fd[0]);
	close(fd[1]);
	waitpid(pid_left, NULL, 0);
	waitpid(pid_right, NULL, 0);
}

/* DOCS : WIFEXITED && WEXITSTATUS-> A voir si macros interdites...
 * 		Si c'est le cas, le code sera a repenser voir les recreer
 * https://sites.uclouvain.be/SystInfo/usr/include/bits/waitstatus.h.html
 */
void	execute_logical(t_node *logical_node)
{
	int	status;

	execute(logical_node->writer);
	wait(&status);
	if (logical_node->type == LOGICAL_AND && WIFEXITED(status)
		&& WEXITSTATUS(status) == 0)
		execute(logical_node->reader);
	else if (logical_node->type == LOGICAL_OR && WIFEXITED(status)
		&& WEXITSTATUS(status) != 0)
		execute(logical_node->reader);
}

void	execute_semicolon(t_node *semi_node)
{
	execute(semi_node->writer);
	execute(semi_node->reader);
}

int	handle_redirections(t_node *cmd)
{
	int	fd;
	int	i;

	i = -1;
	while (++i < cmd->redir_count)
	{
		if (cmd->redirs[i].type == REDIRECT_OUT)
			fd = open(cmd->redirs[i].filename,
					O_WRONLY | O_CREAT | O_TRUNC, 0644);
		else if (cmd->redirs[i].type == APPEND)
			fd = open(cmd->redirs[i].filename,
					O_WRONLY | O_CREAT | O_APPEND, 0644);
		else if (cmd->redirs[i].type == REDIRECT_IN)
			fd = open(cmd->redirs[i].filename, O_RDONLY);
		else if (cmd->redirs[i].type == HEREDOC)
			fd = handle_heredoc(cmd->redirs[i].filename);
		if (fd == -1)
		{
			perror("minishell");
			return (-1);
		}
		if (cmd->redirs[i].type == REDIRECT_IN
			|| cmd->redirs[i].type == HEREDOC)
			dup2(fd, STDIN_FILENO);
		else
			dup2(fd, STDOUT_FILENO);
		close(fd);
	}
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   free_tree.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 18:39:48 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 18:47:30 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	free_tree(t_node *node)
{
	int	i;

	i = 0;
	if (!node)
		return ;
	free_tree(node->writer);
	free_tree(node->reader);
	if (node->type == CMD)
	{
		i = 0;
		while (node->args[i])
		{
			free(node->args[i]);
			i++;
		}
		free(node->args);
	}
	i = 0;
	while (i < node->redir_count)
	{
		free(node->redirs[i].filename);
		i++;
	}
	free(node->redirs);
	free(node);
}

void	free_tokens(t_token	*tokens)
{
	int	i;

	i = 0;
	while (tokens[i].type != END)
	{
		free(tokens[i].value);
		i++;
	}
	free(tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   binary_tree.c                                      :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 11:40:00 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 11:55:26 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

t_node	*create_leaf(char **args)
{
	t_node	*node;

	node = malloc(sizeof(t_node));
	node->type = CMD;
	node->args = args;
	node->writer = NULL;
	node->reader = NULL;
	node->redirs = NULL;
	node->redir_count = 0;
	return (node);
}

t_node	*create_node(t_type type, t_node *left, t_node *right)
{
	t_node	*node;

	node = malloc(sizeof(t_node));
	node->type = type;
	node->args = NULL;
	node->writer = left;
	node->reader = right;
	node->redirs = NULL;
	node->redir_count = 0;
	return (node);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.c                                             :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembo    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/28 21:27:25 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 22:53:59 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

void	print_tree(t_node *node, int depth)
{
	int	i;

	if (!node)
		return ;
	ft_printf("\n");
	//print_tree(node->reader, depth + 4);
	i = 0;
	while (i < depth)
	{
		ft_printf(" ");
		i++;
	}
	if (node->type == CMD)
	{
		ft_printf("CMD: ");
		i = 0;
		while (node->args[i])
		{
			ft_printf("%s ", node->args[i]);
			i++;
		}
		i = 0;
		while (i < node->redir_count)
		{
			ft_printf("[%s %s]", redir_type_str(node->redirs[i].type),
				node->redirs[i].filename);
			i++;
		}
		ft_printf("\n");
	}
	else
	{
		ft_printf("OP: %s\n", type_to_str(node->type));
		print_tree(node->writer, depth + 1);
		print_tree(node->reader, depth + 1);
	}
	//print_tree(node->writer, depth + 4);
}
/*
 * ast = https://deepsource.com/glossary/ast 
 */
int	main(void)
{
	char		*rl;
	t_token		*tokens;
	t_parser	parser;
	t_node		*ast;

	while ((rl = readline("minishell> ")) != NULL)
	{
		if (ft_strlen(rl) > 0)
			add_history(rl);
		ft_printf("\n");
		tokens = tokenize(rl);
		parser = (t_parser){tokens, 0};
		ast = parse(&parser);
		print_tree(ast, 0);
		//execute(ast);
		free_tree(ast);
		free_tokens(tokens);
		free(rl);
	}
	//free_tree(ast);
	//free_tokens(tokens);
	//free(rl);
	return (0);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   to_str_helper.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 19:48:19 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 20:05:45 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

const char	*redir_type_str(t_type type)
{
	switch (type)
	{
		case REDIRECT_IN:	return ("<");
		case REDIRECT_OUT: 	return (">");
		case APPEND:		return (">>");
		case HEREDOC:		return ("<<");
		default:			return ("UNKNOWN REDIR");
	}
}

const char	*type_to_str(t_type type)
{
	switch (type)
	{
		case CMD:			return ("CMD");
		case PIPE:			return ("|");
		case SEMICOLON:		return (";");
		case LOGICAL_AND:	return ("&&");
		case LOGICAL_OR:	return ("||");
		case GROUPING:		return ("()");
		case REDIRECT_IN:
		case REDIRECT_OUT:
		case APPEND:
		case HEREDOC:		return redir_type_str(type);
		default:			return ("UNKNOWN");
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 10:58:34 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 11:39:49 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

static int	is_operator(char c)
{
	return (c == '>' || c == '<' || c == ';'
		|| c == '&' || c == '(' || c == ')');
}

/*
 * Tokenizer based on struct t_type. 
 * 
 */
t_token	*tokenize(char *input)
{
	t_token	*tokens;
	int		i;
	int		pos;
	int		start;

	tokens = malloc(MAX_TOKENS * sizeof(t_token));
	i = 0;
	pos = 0;
	while (input[pos])
	{
		if (ft_isspace(input[pos]))
		{
			pos++;
			continue ;
		}
		start = pos;
		if (ft_strncmp(&input[pos], ">>", 2) == 0)
		{
			tokens[i++] = (t_token){APPEND, ft_strdup(">>")};
			pos += 2;
		}
		else if (ft_strncmp(&input[pos], "<<", 2) == 0)
		{
			tokens[i++] = (t_token){HEREDOC, ft_strdup("<<")};
			pos += 2;
		}
		else if (ft_strncmp(&input[pos], "&&", 2) == 0)
		{
			tokens[i++] = (t_token){LOGICAL_AND, ft_strdup("&&")};
			pos += 2;
		}
		else if (ft_strncmp(&input[pos], "||", 2) == 0)
		{
			tokens[i++] = (t_token){LOGICAL_OR, ft_strdup("||")};
			pos += 2;
		}
		else if (input[pos] == '>')
		{
			tokens[i++] = (t_token){REDIRECT_OUT, ft_strdup(">")};
			pos++;
		}
		else if (input[pos] == '<')
		{
			tokens[i++] = (t_token){REDIRECT_IN, ft_strdup("<")};
			pos++;
		}
		else if (input[pos] == '|')
		{
			tokens[i++] = (t_token){PIPE, ft_strdup("|")};
			pos++;
		}
		else if (input[pos] == ';')
		{
			tokens[i++] = (t_token){SEMICOLON, ft_strdup("")};
			pos++;
		}
		else if (input[pos] == '(')
		{
			tokens[i++] = (t_token){GROUPING_OPEN, ft_strdup("(")};
			pos++;
		}
		else if (input[pos] == ')')
		{
			tokens[i++] = (t_token){GROUPING_CLOSE, ft_strdup(")")};
			pos++;
		}
		else
		{
			while (input[pos] && !ft_isspace(input[pos])
				&& !is_operator(input[pos]))
				pos++;
			tokens[i++] = (t_token){WORD, ft_substr(input, start, pos - start)};
		}
	}
	tokens[i] = (t_token){END, NULL};
	return (tokens);
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   to_str_helper.c                                    :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 19:48:19 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 20:05:45 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

const char	*redir_type_str(t_type type)
{
	switch (type)
	{
		case REDIRECT_IN:	return ("<");
		case REDIRECT_OUT: 	return (">");
		case APPEND:		return (">>");
		case HEREDOC:		return ("<<");
		default:			return ("UNKNOWN REDIR");
	}
}

const char	*type_to_str(t_type type)
{
	switch (type)
	{
		case CMD:			return ("CMD");
		case PIPE:			return ("|");
		case SEMICOLON:		return (";");
		case LOGICAL_AND:	return ("&&");
		case LOGICAL_OR:	return ("||");
		case GROUPING:		return ("()");
		case REDIRECT_IN:
		case REDIRECT_OUT:
		case APPEND:
		case HEREDOC:		return redir_type_str(type);
		default:			return ("UNKNOWN");
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   token.c                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: oilyine- <oleg.ilyine@student42.luxembour  +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/03/30 10:58:34 by oilyine-          #+#    #+#             */
/*   Updated: 2025/03/30 11:39:49 by oilyine-         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../inc/minishell.h"

int	is_operator(char c)
{
	return (c == '>' || c == '<' || c == ';'
		|| c == '&' || c == '(' || c == ')');
}

/*
 * Tokenizer based on struct t_type. 
 * 
 */
t_token	*tokenize(char *input)
{
	t_token	*tokens;
	int		i;
	int		pos;
	int		start;

	tokens = malloc(MAX_TOKENS * sizeof(t_token));
	i = 0;
	pos = 0;
	while (input[pos])
	{
		if (ft_isspace(input[pos]))
		{
			pos++;
			continue ;
		}
		start = pos;
		if (ft_strncmp(&input[pos], ">>", 2) == 0)
		{
			tokens[i++] = (t_token){APPEND, ft_strdup(">>")};
			pos += 2;
		}
		else if (ft_strncmp(&input[pos], "<<", 2) == 0)
		{
			tokens[i++] = (t_token){HEREDOC, ft_strdup("<<")};
			pos += 2;
		}
		else if (ft_strncmp(&input[pos], "&&", 2) == 0)
		{
			tokens[i++] = (t_token){LOGICAL_AND, ft_strdup("&&")};
			pos += 2;
		}
		else if (ft_strncmp(&input[pos], "||", 2) == 0)
		{
			tokens[i++] = (t_token){LOGICAL_OR, ft_strdup("||")};
			pos += 2;
		}
		else if (input[pos] == '>')
		{
			tokens[i++] = (t_token){REDIRECT_OUT, ft_strdup(">")};
			pos++;
		}
		else if (input[pos] == '<')
		{
			tokens[i++] = (t_token){REDIRECT_IN, ft_strdup("<")};
			pos++;
		}
		else if (input[pos] == '|')
		{
			tokens[i++] = (t_token){PIPE, ft_strdup("|")};
			pos++;
		}
		else if (input[pos] == ';')
		{
			tokens[i++] = (t_token){SEMICOLON, ft_strdup("")};
			pos++;
		}
		else if (input[pos] == '(')
		{
			tokens[i++] = (t_token){GROUPING_OPEN, ft_strdup("(")};
			pos++;
		}
		else if (input[pos] == ')')
		{
			tokens[i++] = (t_token){GROUPING_CLOSE, ft_strdup(")")};
			pos++;
		}
		else
		{
			while (input[pos] && !ft_isspace(input[pos])
				&& !is_operator(input[pos]))
				pos++;
			tokens[i++] = (t_token){WORD, ft_substr(input, start, pos - start)};
		}
	}
	tokens[i] = (t_token){END, NULL};
	return (tokens);
}
